using System.Numerics;

public class GoRus // класс
{
    static void Main(string[] args) // точка входа <-- программа начинается здесь
    {
        // I) Примимитивные типы данных:

        // I.1) Целочисленные типы данных ->

        int x = int.MaxValue; // Целочисленный тип данных, хранит 4 байта (32 бита) информации (от -2^31 до 2^31 - 1)
        uint y = uint.MaxValue; // Целочисленный тип данных, хранит 4 байта (32 бита) информации (от 0 до 2^32 - 1)

        long z = long.MaxValue; // Целочисленный тип данных, хранит 8 байт (64 бита) информации (от -2^63 до 2^63 - 1)
        ulong v = ulong.MaxValue; // Целочисленный тип данных, хранит 8 (64 бита) байт информации (от 0 до 2^64 - 1)

        short a = short.MaxValue; // Целочисленный тип данных, хранит 2 байта (16 бит) информации (от - 2^15 до 2^15 - 1)
        ushort b = ushort.MaxValue; // Целочисленный тип данных, хранит 2 байта (16 бит) информации (от 0 до 2^16 - 1)
        
        // ведет себя как ю байт 
        byte c = byte.MaxValue; // Целочисленный тип данных, хранит 1 байт (8 бит) информации (от 0 до 2^8 - 1)

        Console.WriteLine(x + " " + (Pow(2, 31) - 1));
        Console.WriteLine(y + " " + (Pow(2, 32) - 1));

        Console.WriteLine(z + " " + (Pow(2, 63) - 1));
        Console.WriteLine(v + " " + (Pow(2, 64) - 1));

        Console.WriteLine(a + " " + (Pow(2, 15) - 1));
        Console.WriteLine(b + " " + (Pow(2, 16) - 1));

        Console.WriteLine(c + " " + (Pow(2, 8) - 1));

        // I.2) Вещественные типы данных ->
        // или типы данных с плавающей запятой/точкой
        float f = float.MaxValue; // хранит 4 байта (32бита) информации
                                  // ограниченная точность, огромный диапазон данных
        double d = double.MaxValue; // хранит 8 байт (64 бита) информации
                                    // наиболее часто используемый

        Console.WriteLine(f);
        Console.WriteLine(d);

        decimal e = decimal.MaxValue; // Хранит 16 байт (128 бит) информации,
                                      // самая высокая точность, не включая длинную арифметику

        Console.WriteLine(e / 12345678912345678912L);

        // I.3) Булевы типы данных

        bool booleanT = true; // только два положения (правда и ложь)
        bool booleanF = false; // флаги для логического ветвления

        Console.WriteLine(booleanT + " " + booleanF);

        // I.4) Символьный тип данных

        char ch = '9'; // в отличие от строки выражение для символа
                       // записывается в одинарных ковычках

        char ch1 = '@';

        Console.WriteLine(ch + " " + ch1);

        // II) Не-примитивы:

        // II.1) Длинные арифметические типы ->

        BigInteger bigInt = BigInteger.Parse("12345678912345678912345678912345678912345678" +
            "91234567891234567891234567891234567891234567891234567891234567891234567891234" +
            "56789123456789123456789123456789123456789123456789123456789123456789123456789" +
            "12345678912345678912345678912345678912345678912345678912345678912345678912345" +
            "67891234567891234567891234567891234567891234567891234567891234567891234567891" +
            "23456789123456789123456789123456789123456789123456789123456789123456789123456" +
            "78912345678912345678912345678912345678912345678912345678912345678912345678912" +
            "34567891234567891234567891234567891234567891234567891234567891234567891234567" +
            "89123456789123456789123456789123456789123456789123456789123456789123456789123" +
            "45678912345678912345678912345678912345678912345678912345678912345678912345678" +
            "91234567891234567891234567891234567891234567891234567891234567891234567891234" +
            "56789123456789123456789123456789123456789123456789123456789123456789123456789" +
            "12345678912345678912345678912345678912345678912345678912345678912345678912345" +
            "67891234567891234567891234567891234567891234567891234567891234567891234567891" +
            "23456789123456789123456789"); // поключаем с помощью: using System.Numerics;
                                           // в самом начале программы до первого класса

        Console.WriteLine(bigInt);

        bigInt = BigInteger.Multiply(bigInt, bigInt); // квадрат числа биг инт
        bigInt = BigInteger.Multiply(bigInt, bigInt);
        bigInt = BigInteger.Multiply(bigInt, bigInt);
        bigInt = BigInteger.Multiply(bigInt, bigInt);
        bigInt = BigInteger.Multiply(bigInt, bigInt);
        bigInt = BigInteger.Multiply(bigInt, bigInt);
        bigInt = BigInteger.Multiply(bigInt, bigInt);
        bigInt = BigInteger.Multiply(bigInt, bigInt);             

        Console.WriteLine("\n" + bigInt); // чтобы понять, насколько велики границы
                                          // этого широкого типа данных

        // II.2) Строковый тип

        string s = "Рус - толстопуз!!!"; // хранит примерно до 2 ГигаБайт данных
                                         // (до 16 ГигаБит) информации, фактически не ограничен

        Console.WriteLine(s);

        // сама строка представляет собой массив характеров или символов (чаров)

        Console.WriteLine(s[0] + " " + s[9]); // строка допускает операции сложения (конкатенации)

        s = "Рус не индус " + 989; // конкатенация

        Console.WriteLine(s); 
    }

    // метод класса
    public static ulong Pow(uint b, int power) // сигнатура входных данных
    {
        // тело метода

        ulong result = 1;

        // цикл фор
        for (int i = 0; i < power; i++) // не оптимизированное возведение в степень,
                                        // для учебных целей
        {
            result = result * b;
        }

        // возвращаемое значение
        return result;
    }

    // методы, конструкторы класса и переменные класса -> внутри класса, но вне Мейна
}